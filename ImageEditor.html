<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LayerLab</title>
    
    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="LayerLab">
    <meta name="theme-color" content="#121212">
    <link rel="apple-touch-icon" href="./image_editor_icon_192.png">
    <link rel="manifest" href="manifest.json">

    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #0a84ff;
            --text-color: #ffffff;
            --secondary-text: #8e8e93;
            --border-color: #38383a;
            --nav-bg: #2c2c2e;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        header {
            height: 50px;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 8px;
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            z-index: 10;
        }
        h1 { font-size: 18px; margin: 0; font-weight: 600; flex: 1; text-align: center; }
        .header-btn { background: none; border: none; color: var(--primary-color); font-size: 14px; font-weight: 500; cursor: pointer; padding: 0 10px; }
        .header-icon-btn { font-size: 18px; color: var(--text-color); background: none; border: none; padding: 8px; }

        /* Main Area */
        main {
            flex: 1; position: relative;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden;
            touch-action: none;
            background-image: linear-gradient(45deg, #2a2a2a 25%, transparent 25%), linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #2a2a2a 75%), linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        canvas {
            max-width: 100%; max-height: 100%;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transform-origin: 0 0;
            /* Pointer events are handled via JS, but prevent default touch actions */
            touch-action: none; 
        }

        /* Controls Section */
        #controls {
            background-color: var(--surface-color);
            border-top: 1px solid var(--border-color);
            padding: 16px;
            padding-bottom: 10px;
            display: flex; flex-direction: column; gap: 12px;
            max-height: 40vh; overflow-y: auto;
            z-index: 20;
        }

        /* Navigation Bar */
        #navbar {
            background-color: var(--nav-bg);
            display: flex;
            height: 60px;
            border-top: 1px solid var(--border-color);
            padding-bottom: max(0px, env(safe-area-inset-bottom)); 
        }
        .nav-item {
            flex: 1;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--secondary-text);
            font-size: 10px; font-weight: 500;
            border: none; background: none;
        }
        .nav-item.active { color: var(--primary-color); }
        .nav-icon { font-size: 20px; margin-bottom: 2px; }

        /* Tool UI */
        .tool-row { display: flex; gap: 10px; align-items: center; }
        .tool-group { display: flex; flex: 1; gap: 8px; background: #2c2c2e; padding: 4px; border-radius: 8px; }
        .tool-btn {
            flex: 1; background: transparent; border: none; color: var(--text-color);
            padding: 8px 0; border-radius: 6px; font-size: 13px; font-weight: 500;
        }
        .tool-btn.active { background-color: var(--primary-color); color: white; }
        .action-btn {
            background-color: #3a3a3c; color: white; border: none;
            padding: 8px 12px; border-radius: 8px; font-size: 13px;
        }
        .action-btn.active { background-color: var(--primary-color); }

        /* Sliders */
        .slider-container { display: flex; align-items: center; gap: 10px; }
        .slider-label { font-size: 12px; color: var(--secondary-text); width: 60px; }
        input[type="range"] {
            flex: 1; height: 4px; border-radius: 2px; background: #3a3a3c;
            outline: none; -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px;
            border-radius: 50%; background: var(--primary-color); cursor: pointer; border: 2px solid #fff;
        }

        /* Panels */
        .panel { display: none; }
        .panel.active { display: flex; flex-direction: column; gap: 12px; }

        /* States */
        #empty-state { text-align: center; color: var(--secondary-text); pointer-events: none; position: absolute; }
        
        /* Toast */
        #toast {
            position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9); color: #000;
            padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 500;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        #toast.show { opacity: 1; }

        input[type="file"] { display: none; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<header>
    <div style="display:flex; gap:5px;">
        <button class="header-icon-btn" onclick="undo()">‚Ü©Ô∏è</button>
        <button class="header-icon-btn" onclick="redo()">‚Ü™Ô∏è</button>
    </div>
    <h1 id="pageTitle">LayerLab</h1>
    <button class="header-btn" onclick="saveImage()">Save</button>
</header>

    <main id="canvasViewport">
        <div id="empty-state">
            <h2>No Image</h2>
            <p>Import Base to start</p>
        </div>
        <canvas id="mainCanvas"></canvas>
    </main>

<!-- Controls Area -->
<div id="controls">
    
    <!-- Common Import -->
    <div class="tool-row" id="import-row">
        <button class="action-btn" style="flex:1" onclick="document.getElementById('baseInput').click()">Import Base</button>
        <button class="action-btn" style="flex:1" id="btnOverlay" onclick="document.getElementById('overlayInput').click()">Import Overlay</button>
    </div>

    <div class="tool-row" id="view-row">
        <button class="action-btn" style="flex:1" onclick="resetView()">Reset View</button>
    </div>

    <!-- MODE: BLEND -->
    <div id="panel-blend" class="panel active">
        <div class="tool-group">
            <button class="tool-btn active" id="btnPaint" onclick="setBrushMode('paint')">Paint (Show)</button>
            <button class="tool-btn" id="btnErase" onclick="setBrushMode('erase')">Erase (Hide)</button>
        </div>
        <div class="slider-container">
            <span class="slider-label">Size</span>
            <input type="range" id="sizeRange" min="1" max="100" value="10">
            <span class="slider-label" id="sizeVal">10%</span>
        </div>
        <div class="slider-container">
            <span class="slider-label">Softness</span>
            <input type="range" id="softRange" min="0" max="100" value="70">
            <span class="slider-label" id="softVal">70%</span>
        </div>
        <div class="tool-row">
            <button class="action-btn" onclick="invertMask()">Invert Alpha</button>
            <button class="action-btn danger" onclick="clearMask()">Clear Mask</button>
        </div>
    </div>

    <!-- MODE: BLUR -->
    <div id="panel-blur" class="panel">
        <div class="tool-group">
            <button class="tool-btn active" id="btnShapeCircle" onclick="setBrushShape('circle')">Circle</button>
            <button class="tool-btn" id="btnShapeRect" onclick="setBrushShape('rect')">Rectangle</button>
        </div>
        <!-- Size BEFORE Strength -->
        <div class="slider-container">
            <span class="slider-label">Size</span>
            <input type="range" id="blurSizeRange" min="1" max="100" value="10">
            <span class="slider-label" id="blurSizeVal">10%</span>
        </div>
        <div class="slider-container">
            <span class="slider-label">Strength</span>
            <input type="range" id="blurStrengthRange" min="1" max="50" value="10">
            <span class="slider-label" id="blurVal">10px</span>
        </div>
        <div class="slider-container">
            <span class="slider-label">Softness</span>
            <input type="range" id="blurSoftRange" min="0" max="100" value="20">
            <span class="slider-label" id="blurSoftVal">20%</span>
        </div>
    </div>

    <!-- MODE: RETOUCH -->
    <div id="panel-retouch" class="panel">
        <div class="tool-row">
            <button class="action-btn" id="btnPickSource" onclick="setRetouchMode('pick')">Pick Source</button>
            <button class="action-btn" id="btnPaintSource" onclick="setRetouchMode('paint')">Paint</button>
        </div>
        <div style="text-align:center; font-size:12px; color:var(--secondary-text);" id="retouchStatus">
            Tap "Pick Source" then tap image
        </div>
        <div class="slider-container">
            <span class="slider-label">Size</span>
            <input type="range" id="retouchSizeRange" min="1" max="100" value="10">
            <span class="slider-label" id="retouchSizeVal">10%</span>
        </div>
        <div class="slider-container">
            <span class="slider-label">Softness</span>
            <input type="range" id="retouchSoftRange" min="0" max="100" value="20">
            <span class="slider-label" id="retouchSoftVal">20%</span>
        </div>
    </div>

</div>

<!-- Navigation Bar -->
<nav id="navbar">
    <button class="nav-item active" onclick="switchMode('blend')">
        <span class="nav-icon">‚ú®</span>
        Blend
    </button>
    <button class="nav-item" onclick="switchMode('blur')">
        <span class="nav-icon">üíß</span>
        Blur
    </button>
    <button class="nav-item" onclick="switchMode('retouch')">
        <span class="nav-icon">üßπ</span>
        Retouch
    </button>
</nav>

<input type="file" id="baseInput" accept="image/*">
<input type="file" id="overlayInput" accept="image/*">
<div id="toast">Message</div>

<script>
    /**
     * APP ARCHITECTURE
     */
    const state = {
        mode: 'blend', 
        baseImg: null,
        overlayImg: null,
        
        // Blend
        brushMode: 'paint', 
        brushSize: 10,
        brushSoftness: 0.7, 
        
        // Blur
        blurStrength: 10,
        blurSize: 10,
        blurShape: 'circle',
        blurSoftness: 0.2, // 0 = Hard Edge, 1 = Full Fade

        // Retouch
        retouchMode: 'pick',
        retouchSize: 10,
        retouchSoftness: 0.2,
        cloneSource: {x: null, y: null},

        isDrawing: false,
        hasInteracted: false,
        cursor: { x: null, y: null },
        suppressOverlays: false,

        // View Transform
        view: {
            scale: 1,
            offsetX: 0,
            offsetY: 0
        },

        // Center Preview
        showCenterPreview: false,
        centerPreviewTimer: null
    };

    // History Stacks
    const MAX_HISTORY = 20;
    const maskHistory = []; 
    let maskIndex = -1;

    const baseHistory = []; 
    let baseIndex = -1;

    // Canvases
    const canvas = document.getElementById('mainCanvas');
    const viewport = document.getElementById('canvasViewport');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    let baseCanvas = null;
    let overlayCanvas = null;
    let maskCanvas = null;

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
    const BLUR_STRENGTH_STEPS = [8, 20, 40, 70];
    const BLUR_STRENGTH_SCALE = 1.4;
    const VIEW_MIN_SCALE = 0.5;
    const VIEW_MAX_SCALE = 6;
    let blurLayers = [];
    let blurLayersReady = false;

    // UI Refs
    const emptyState = document.getElementById('empty-state');
    const toastEl = document.getElementById('toast');
    const pageTitle = document.getElementById('pageTitle');
    const sizeRange = document.getElementById('sizeRange');
    const softRange = document.getElementById('softRange');
    const blurStrengthRange = document.getElementById('blurStrengthRange');
    const blurSizeRange = document.getElementById('blurSizeRange');
    const blurSoftRange = document.getElementById('blurSoftRange');
    const retouchSizeRange = document.getElementById('retouchSizeRange');
    const retouchSoftRange = document.getElementById('retouchSoftRange');

    // Init
    function init() {
        setupInputs();
        
        function animate() {
            render();
            requestAnimationFrame(animate);
        }
        animate();
    }

    function setupInputs() {
        // Helper to trigger center preview
        const triggerPreview = () => {
            state.showCenterPreview = true;
            clearTimeout(state.centerPreviewTimer);
            state.centerPreviewTimer = setTimeout(() => {
                state.showCenterPreview = false;
            }, 2000); // Show for 2 seconds
        };

        // Blend
        sizeRange.addEventListener('input', (e) => {
            state.brushSize = parseInt(e.target.value);
            document.getElementById('sizeVal').textContent = state.brushSize + '%';
            triggerPreview();
        });
        softRange.addEventListener('input', (e) => {
            state.brushSoftness = parseInt(e.target.value) / 100;
            document.getElementById('softVal').textContent = e.target.value + '%';
            triggerPreview();
        });

        // Blur
        blurSizeRange.addEventListener('input', (e) => {
            state.blurSize = parseInt(e.target.value);
            document.getElementById('blurSizeVal').textContent = state.blurSize + '%';
            triggerPreview();
        });
        blurStrengthRange.addEventListener('input', (e) => {
            state.blurStrength = parseInt(e.target.value);
            document.getElementById('blurVal').textContent = state.blurStrength + 'px';
            triggerPreview();
        });
        blurSoftRange.addEventListener('input', (e) => {
            state.blurSoftness = parseInt(e.target.value) / 100;
            document.getElementById('blurSoftVal').textContent = e.target.value + '%';
            triggerPreview();
        });

        // Retouch
        retouchSizeRange.addEventListener('input', (e) => {
            state.retouchSize = parseInt(e.target.value);
            document.getElementById('retouchSizeVal').textContent = state.retouchSize + '%';
            triggerPreview();
        });
        retouchSoftRange.addEventListener('input', (e) => {
            state.retouchSoftness = parseInt(e.target.value) / 100;
            document.getElementById('retouchSoftVal').textContent = e.target.value + '%';
            triggerPreview();
        });

        // Files
        document.getElementById('baseInput').addEventListener('change', handleBaseSelect);
        document.getElementById('overlayInput').addEventListener('change', handleOverlaySelect);

        // POINTER EVENTS (Modern Standard)
        // We replace Mouse/Touch with Pointer for unified handling
        viewport.addEventListener('contextmenu', (e) => e.preventDefault());

        viewport.addEventListener('wheel', (e) => {
            if (!baseCanvas) return;
            e.preventDefault();
            const pt = getScreenPoint(e);
            const zoom = e.deltaY < 0 ? 1.1 : 0.9;
            zoomAt(pt, zoom);
            render();
        }, { passive: false });

        viewport.addEventListener('pointerdown', (e) => {
            if (!baseCanvas) return;
            e.preventDefault();
            viewport.setPointerCapture(e.pointerId);

            const onCanvas = e.target === canvas;
            const pt = getScreenPoint(e);
            activePointers.set(e.pointerId, { pt, onCanvas });

            if (activePointers.size === 2) {
                startPinch();
                return;
            }

            const isPanGesture = e.button === 2 || e.shiftKey;
            if (isPanGesture) {
                startPan(e, pt);
                return;
            }

            if (onCanvas) {
                updateCursor(e);
                startStroke(e);
            }
        });
        
        viewport.addEventListener('pointermove', (e) => {
            const entry = activePointers.get(e.pointerId);
            if (entry) {
                entry.pt = getScreenPoint(e);
                activePointers.set(e.pointerId, entry);
            }

            if (activePointers.size === 2 && pinchStart) {
                updatePinch();
                return;
            }

            if (state.isPanning && panPointerId === e.pointerId) {
                updatePan(e);
                return;
            }

            if (entry && entry.onCanvas) {
                updateCursor(e);
                moveStroke(e);
            }
        });
        
        viewport.addEventListener('pointerup', (e) => {
            activePointers.delete(e.pointerId);
            if (activePointers.size < 2) {
                pinchStart = null;
            }
            if (panPointerId === e.pointerId) {
                state.isPanning = false;
                panPointerId = null;
            }
            endStroke();
            viewport.releasePointerCapture(e.pointerId);
        });

        viewport.addEventListener('pointercancel', (e) => {
            activePointers.delete(e.pointerId);
            if (activePointers.size < 2) {
                pinchStart = null;
            }
            if (panPointerId === e.pointerId) {
                state.isPanning = false;
                panPointerId = null;
            }
            endStroke();
            viewport.releasePointerCapture(e.pointerId);
        });
    }

    const activePointers = new Map();
    let panPointerId = null;
    let panStart = null;
    let panOffsetStart = null;
    let pinchStart = null;

    function clampScale(scale) {
        return Math.min(VIEW_MAX_SCALE, Math.max(VIEW_MIN_SCALE, scale));
    }

    function applyViewTransform() {
        canvas.style.transform = `translate(${state.view.offsetX}px, ${state.view.offsetY}px) scale(${state.view.scale})`;
    }

    function getScreenPoint(e) {
        return { x: e.clientX, y: e.clientY };
    }

    function getImagePointFromScreen(pt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (pt.x - rect.left) * scaleX,
            y: (pt.y - rect.top) * scaleY
        };
    }

    function zoomAt(pt, factor) {
        const oldScale = state.view.scale;
        const newScale = clampScale(oldScale * factor);
        const ratio = newScale / oldScale;
        state.view.offsetX = pt.x - (pt.x - state.view.offsetX) * ratio;
        state.view.offsetY = pt.y - (pt.y - state.view.offsetY) * ratio;
        state.view.scale = newScale;
        applyViewTransform();
    }

    function startPan(e, pt) {
        state.isPanning = true;
        panPointerId = e.pointerId;
        panStart = pt;
        panOffsetStart = { x: state.view.offsetX, y: state.view.offsetY };
    }

    function updatePan(e) {
        if (!panStart || !panOffsetStart) return;
        const pt = getScreenPoint(e);
        state.view.offsetX = panOffsetStart.x + (pt.x - panStart.x);
        state.view.offsetY = panOffsetStart.y + (pt.y - panStart.y);
        applyViewTransform();
        render();
    }

    function startPinch() {
        const entries = Array.from(activePointers.values());
        if (entries.length < 2) return;
        const p0 = entries[0].pt;
        const p1 = entries[1].pt;
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const dist = Math.hypot(dx, dy);
        const center = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
        const rect = canvas.getBoundingClientRect();
        const baseLeft = rect.left - state.view.offsetX;
        const baseTop = rect.top - state.view.offsetY;
        const baseWidth = rect.width / state.view.scale;
        const baseHeight = rect.height / state.view.scale;
        const anchor = getImagePointFromScreen(center);

        pinchStart = {
            dist,
            center,
            scale: state.view.scale,
            offsetX: state.view.offsetX,
            offsetY: state.view.offsetY,
            baseLeft,
            baseTop,
            baseWidth,
            baseHeight,
            anchor
        };
    }

    function updatePinch() {
        const entries = Array.from(activePointers.values());
        if (entries.length < 2) return;
        const p0 = entries[0].pt;
        const p1 = entries[1].pt;
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const dist = Math.hypot(dx, dy);
        const center = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
        if (!pinchStart) return;

        const factor = dist / pinchStart.dist;
        const newScale = clampScale(pinchStart.scale * factor);

        const imgX = pinchStart.anchor.x / canvas.width;
        const imgY = pinchStart.anchor.y / canvas.height;
        const scaledWidth = pinchStart.baseWidth * newScale;
        const scaledHeight = pinchStart.baseHeight * newScale;

        state.view.scale = newScale;
        state.view.offsetX = center.x - pinchStart.baseLeft - imgX * scaledWidth;
        state.view.offsetY = center.y - pinchStart.baseTop - imgY * scaledHeight;

        applyViewTransform();
        render();
    }

    function resetView(shouldRender = true) {
        state.view.scale = 1;
        state.view.offsetX = 0;
        state.view.offsetY = 0;
        applyViewTransform();
        if (shouldRender) render();
    }

    function updateCursor(e) {
        if (!baseCanvas) return;
        const pt = getScreenPoint(e);
        const imgPt = getImagePointFromScreen(pt);
        state.cursor.x = imgPt.x;
        state.cursor.y = imgPt.y;
    }

    function getCoords(e) {
        const pt = getScreenPoint(e);
        return getImagePointFromScreen(pt);
    }

    function setupListeners() { /* Handled inline */ }

    /**
     * HISTORY SYSTEM
     */
    function pushHistory() {
        if (state.mode === 'blend') {
            pushMaskHistory();
        } else {
            if (!baseCanvas) return;
            if (baseIndex < baseHistory.length - 1) {
                baseHistory.splice(baseIndex + 1);
            }
            baseHistory.push(baseCanvas.toDataURL());
            if (baseHistory.length > MAX_HISTORY) {
                baseHistory.shift();
            } else {
                baseIndex++;
            }
        }
    }

    function pushMaskHistory() {
        if (!maskCanvas) return;
        if (maskIndex < maskHistory.length - 1) {
            maskHistory.splice(maskIndex + 1);
        }
        maskHistory.push(maskCanvas.toDataURL());
        if (maskHistory.length > MAX_HISTORY) {
            maskHistory.shift();
        } else {
            maskIndex++;
        }
    }

    function undo() {
        if (state.mode === 'blend') {
            if (maskIndex > 0) {
                maskIndex--;
                restoreMaskState(maskIndex);
                showToast('Undo');
            }
        } else {
            if (baseIndex > 0) {
                baseIndex--;
                restoreBaseState(baseIndex);
                showToast('Undo');
            }
        }
    }

    function redo() {
        if (state.mode === 'blend') {
            if (maskIndex < maskHistory.length - 1) {
                maskIndex++;
                restoreMaskState(maskIndex);
                showToast('Redo');
            }
        } else {
            if (baseIndex < baseHistory.length - 1) {
                baseIndex++;
                restoreBaseState(baseIndex);
                showToast('Redo');
            }
        }
    }

    function restoreBaseState(index) {
        const dataUrl = baseHistory[index];
        if (!dataUrl) return;
        const img = new Image();
        const expectedIndex = index;
        img.onload = () => {
            if (baseIndex !== expectedIndex) return;
            // Recreate canvas to clear all state including clip regions
            const oldWidth = baseCanvas.width;
            const oldHeight = baseCanvas.height;
            baseCanvas.width = oldWidth; // This resets all canvas state
            baseCanvas.height = oldHeight;
            const bCtx = baseCanvas.getContext('2d', { willReadFrequently: true });
            bCtx.drawImage(img, 0, 0);
            render();
        };
        img.src = dataUrl;
    }

    function restoreMaskState(index) {
        const dataUrl = maskHistory[index];
        const img = new Image();
        img.onload = () => {
            if (maskIndex !== index) return;
            const mCtx = maskCanvas.getContext('2d');
            mCtx.clearRect(0,0, maskCanvas.width, maskCanvas.height);
            mCtx.drawImage(img, 0, 0);
            render();
        };
        img.src = dataUrl;
    }

    /**
     * FILE HANDLING
     */
    function handleBaseSelect(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                state.baseImg = img;
                baseCanvas = document.createElement('canvas');
                baseCanvas.width = img.width;
                baseCanvas.height = img.height;
                baseCanvas.getContext('2d', { willReadFrequently: true }).drawImage(img, 0, 0);

                canvas.width = img.width;
                canvas.height = img.height;
                resetView();
                
                maskHistory.length = 0; maskIndex = -1;
                baseHistory.length = 0; baseIndex = -1;
                pushHistory(); 

                emptyState.style.display = 'none';
                showToast('Base loaded');
                buildBlurLayers();
                render();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    function handleOverlaySelect(e) {
        if (!state.baseImg) {
            showToast('Please import Base Image first');
            return;
        }
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                state.overlayImg = img;
                setupOverlayAndMask();
                showToast('Overlay loaded');
                if(state.mode === 'blend') render();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    function setupOverlayAndMask() {
        overlayCanvas = document.createElement('canvas');
        overlayCanvas.width = canvas.width;
        overlayCanvas.height = canvas.height;
        const oCtx = overlayCanvas.getContext('2d');

        maskCanvas = document.createElement('canvas');
        maskCanvas.width = canvas.width;
        maskCanvas.height = canvas.height;
        const mCtx = maskCanvas.getContext('2d', { willReadFrequently: true });

        const bW = canvas.width; const bH = canvas.height;
        const oW = state.overlayImg.width; const oH = state.overlayImg.height;
        const baseRatio = bW / bH;
        const overlayRatio = oW / oH;
        
        let drawW, drawH, drawX, drawY;
        if (Math.abs(baseRatio - overlayRatio) < 0.001) {
            drawW = bW; drawH = bH; drawX = 0; drawY = 0;
        } else {
            const scale = Math.min(bW / oW, bH / oH);
            drawW = oW * scale; drawH = oH * scale;
            drawX = (bW - drawW) / 2; drawY = (bH - drawH) / 2;
        }
        oCtx.drawImage(state.overlayImg, drawX, drawY, drawW, drawH);

        mCtx.fillStyle = '#FFFFFF';
        mCtx.fillRect(0, 0, canvas.width, canvas.height);

        // Initialize mask history so the very first stroke can be undone
        maskHistory.length = 0;
        maskIndex = -1;
        pushMaskHistory();
    }

    /**
     * MODE SWITCHING
     */
    function switchMode(newMode) {
        state.mode = newMode;
        
        document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
        const navItems = document.querySelectorAll('.nav-item');
        if(newMode === 'blend') navItems[0].classList.add('active');
        if(newMode === 'blur') navItems[1].classList.add('active');
        if(newMode === 'retouch') navItems[2].classList.add('active');

        document.querySelectorAll('.panel').forEach(el => el.classList.remove('active'));
        document.getElementById('panel-' + newMode).classList.add('active');

        const btnOverlay = document.getElementById('btnOverlay');
        if (newMode === 'blend') {
            btnOverlay.classList.remove('hidden');
        } else {
            btnOverlay.classList.add('hidden');
        }

        pageTitle.textContent = newMode.charAt(0).toUpperCase() + newMode.slice(1);

        const stack = (newMode === 'blend') ? maskHistory : baseHistory;
        const idx = (newMode === 'blend') ? maskIndex : baseIndex;
        
        if (stack.length === 0 && baseCanvas) {
            pushHistory();
        }

        render();
    }

    /**
     * RENDERING & CURSORS
     */
    function render(options = {}) {
        if (!baseCanvas) return;
        const showOverlays = options.showOverlays !== false && !state.suppressOverlays;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(baseCanvas, 0, 0);

        if (state.mode === 'blend' && overlayCanvas) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.drawImage(overlayCanvas, 0, 0);
            tCtx.globalCompositeOperation = 'destination-in';
            tCtx.drawImage(maskCanvas, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0);
        }

        // Draw Cursors & Previews
        if (showOverlays) {
            if (state.cursor.x !== null) drawCursorOverlay();
            if (state.showCenterPreview) drawCenterPreview();
        }
    }

    function drawCenterPreview() {
        let size = 0;
        let color = 'lime'; 
        let shape = 'circle';

        if (state.mode === 'blend') {
            size = (state.brushSize / 100) * canvas.width;
        } else if (state.mode === 'blur') {
            size = (state.blurSize / 100) * canvas.width;
            shape = state.blurShape;
        } else if (state.mode === 'retouch') {
            size = (state.retouchSize / 100) * canvas.width;
        }

        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 4; 
        ctx.setLineDash([10, 10]);

        ctx.beginPath();
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        if (shape === 'circle') {
            ctx.arc(cx, cy, size/2, 0, Math.PI*2);
        } else {
            ctx.rect(cx - size/2, cy - size/2, size, size);
        }
        ctx.stroke();
        ctx.restore();
    }

    function drawCursorOverlay() {
        ctx.save();
        
        let size = 0;
        let color = 'white';
        let shape = 'circle';

        if (state.mode === 'blend') {
            size = (state.brushSize / 100) * canvas.width;
            color = 'cyan';
        } else if (state.mode === 'blur') {
            size = (state.blurSize / 100) * canvas.width;
            color = 'magenta';
            shape = state.blurShape;
        } else if (state.mode === 'retouch') {
            size = (state.retouchSize / 100) * canvas.width;
            color = 'yellow';
        }

        ctx.lineWidth = 2;
        ctx.strokeStyle = color;
        ctx.setLineDash([5, 5]);

        ctx.beginPath();
        if (shape === 'circle') {
            ctx.arc(state.cursor.x, state.cursor.y, size/2, 0, Math.PI*2);
        } else {
            ctx.rect(state.cursor.x - size/2, state.cursor.y - size/2, size, size);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        if (state.mode === 'retouch' && state.cloneSource.x !== null) {
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.arc(state.cloneSource.x, state.cloneSource.y, size/2, 0, Math.PI*2);
            ctx.stroke();
        }

        ctx.restore();
    }

    /**
     * INTERACTION
     */
    let retouchStartPos = null;

    function startStroke(e) {
        if (!baseCanvas) return;
        const { x, y } = getCoords(e);

        state.isDrawing = true;
        state.hasInteracted = false;

        if (state.mode === 'blend') {
            if (!overlayCanvas) return;
            paintOnMask(x, y);
            state.hasInteracted = true; // Count down-up as a stroke
        } else if (state.mode === 'blur') {
            applyBlur(x, y);
            state.hasInteracted = true; // Count down-up as a stroke
        } else if (state.mode === 'retouch') {
            if (state.retouchMode === 'pick') {
                state.cloneSource = {x, y};
                document.getElementById('retouchStatus').textContent = "Source Set. Tap 'Paint' to apply.";
                document.getElementById('btnPaintSource').classList.add('active');
                document.getElementById('btnPickSource').classList.remove('active');
                state.isDrawing = false; // Picking source shouldn't create history
                state.hasInteracted = false;
                render();
            } else {
                if (state.cloneSource.x === null) { showToast('Pick a source first!'); state.isDrawing = false; return; }
                retouchStartPos = {x, y}; 
                applyRetouch(x, y);
                state.hasInteracted = true; // Count down-up as a stroke
            }
        }
    }

    function moveStroke(e) {
        if (!state.isDrawing) return;
        const { x, y } = getCoords(e);

        state.hasInteracted = true;

        if (state.mode === 'blend') paintOnMask(x, y);
        else if (state.mode === 'blur') applyBlur(x, y);
        else if (state.mode === 'retouch' && state.retouchMode === 'paint') applyRetouch(x, y);
    }

    function endStroke() {
        if (state.isDrawing && state.hasInteracted) {
            pushHistory();
        }
        state.isDrawing = false;
        state.hasInteracted = false;
        retouchStartPos = null;
    }

    /**
     * FEATURES
     */

    // 1. BLEND
    function setBrushMode(mode) {
        state.brushMode = mode;
        document.getElementById('btnPaint').className = mode === 'paint' ? 'tool-btn active' : 'tool-btn';
        document.getElementById('btnErase').className = mode === 'erase' ? 'tool-btn active' : 'tool-btn';
    }

    function paintOnMask(x, y) {
        const mCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
        const r = (state.brushSize / 100) * canvas.width / 2;
        drawBrushLogic(mCtx, x, y, r, state.brushSoftness, state.brushMode);
        render();
    }

    function drawBrushLogic(ctx, x, y, r, softness, mode) {
        ctx.save();
        ctx.beginPath();
        
        const hardness =1.0 - softness;
        const innerR = r * hardness;

        if (mode === 'erase') {
            ctx.globalCompositeOperation = 'destination-out';
            const grad = ctx.createRadialGradient(x, y, innerR, x, y, r);
            grad.addColorStop(0, 'rgba(0,0,0,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
        } else {
            ctx.globalCompositeOperation = 'source-over';
            const grad = ctx.createRadialGradient(x, y, innerR, x, y, r);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
        }
        
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // 2. BLUR (Soft Edge Vignette Algorithm)
    function setBrushShape(shape) {
        state.blurShape = shape;
        document.getElementById('btnShapeCircle').className = shape === 'circle' ? 'tool-btn active' : 'tool-btn';
        document.getElementById('btnShapeRect').className = shape === 'rect' ? 'tool-btn active' : 'tool-btn';
    }

    function buildGaussianKernel(radius, sigma) {
        const size = radius * 2 + 1;
        const kernel = new Float32Array(size);
        const sigma2 = sigma * sigma;
        let sum = 0;
        for (let i = -radius; i <= radius; i++) {
            const value = Math.exp(-(i * i) / (2 * sigma2));
            kernel[i + radius] = value;
            sum += value;
        }
        for (let i = 0; i < size; i++) {
            kernel[i] /= sum;
        }
        return kernel;
    }

    function drawFallbackBlur(sourceCanvas, targetCtx, strength) {
        const w = sourceCanvas.width;
        const h = sourceCanvas.height;
        const sigma = Math.max(0.6, strength * 0.6);
        const radius = Math.min(40, Math.max(2, Math.ceil(sigma * 2.5)));

        const srcCtx = sourceCanvas.getContext('2d', { willReadFrequently: true });
        const srcData = srcCtx.getImageData(0, 0, w, h);
        const src = srcData.data;
        const kernel = buildGaussianKernel(radius, sigma);

        const tmp = new Float32Array(src.length);
        const dst = new Uint8ClampedArray(src.length);

        const clampX = (x) => (x < 0 ? 0 : x >= w ? w - 1 : x);
        const clampY = (y) => (y < 0 ? 0 : y >= h ? h - 1 : y);

        // Horizontal pass
        for (let y = 0; y < h; y++) {
            const row = y * w;
            for (let x = 0; x < w; x++) {
                let r = 0, g = 0, b = 0, a = 0;
                for (let k = -radius; k <= radius; k++) {
                    const ix = clampX(x + k);
                    const idx = (row + ix) * 4;
                    const wgt = kernel[k + radius];
                    r += src[idx] * wgt;
                    g += src[idx + 1] * wgt;
                    b += src[idx + 2] * wgt;
                    a += src[idx + 3] * wgt;
                }
                const outIdx = (row + x) * 4;
                tmp[outIdx] = r;
                tmp[outIdx + 1] = g;
                tmp[outIdx + 2] = b;
                tmp[outIdx + 3] = a;
            }
        }

        // Vertical pass
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                let r = 0, g = 0, b = 0, a = 0;
                for (let k = -radius; k <= radius; k++) {
                    const iy = clampY(y + k);
                    const idx = (iy * w + x) * 4;
                    const wgt = kernel[k + radius];
                    r += tmp[idx] * wgt;
                    g += tmp[idx + 1] * wgt;
                    b += tmp[idx + 2] * wgt;
                    a += tmp[idx + 3] * wgt;
                }
                const outIdx = (y * w + x) * 4;
                dst[outIdx] = r;
                dst[outIdx + 1] = g;
                dst[outIdx + 2] = b;
                dst[outIdx + 3] = a;
            }
        }

        const outData = new ImageData(dst, w, h);
        targetCtx.putImageData(outData, 0, 0);
    }

    function buildBlurLayers() {
        if (!baseCanvas) return;
        blurLayersReady = false;
        blurLayers = [];
        let idx = 0;
        showToast('Building blur layers...');

        const buildNext = () => {
            if (!baseCanvas) return;
            if (idx >= BLUR_STRENGTH_STEPS.length) {
                blurLayersReady = true;
                showToast('Blur ready');
                return;
            }

            const strength = BLUR_STRENGTH_STEPS[idx];
            const layerCanvas = document.createElement('canvas');
            layerCanvas.width = canvas.width;
            layerCanvas.height = canvas.height;
            const lCtx = layerCanvas.getContext('2d');

            const canUseFilter = !isIOS && typeof lCtx.filter !== 'undefined';
            if (canUseFilter) {
                lCtx.filter = `blur(${strength}px)`;
                lCtx.drawImage(baseCanvas, 0, 0);
                lCtx.filter = 'none';
            } else {
                drawFallbackBlur(baseCanvas, lCtx, strength);
            }

            blurLayers.push({ strength, canvas: layerCanvas });
            idx++;
            setTimeout(buildNext, 0);
        };

        buildNext();
    }

    function getBlurLayerByStrength(strength) {
        if (!blurLayers.length) return null;
        const target = Math.min(BLUR_STRENGTH_STEPS[BLUR_STRENGTH_STEPS.length - 1], strength * BLUR_STRENGTH_SCALE);
        let best = blurLayers[0];
        let bestDiff = Math.abs(best.strength - target);
        for (let i = 1; i < blurLayers.length; i++) {
            const layer = blurLayers[i];
            const diff = Math.abs(layer.strength - target);
            if (diff < bestDiff) {
                best = layer;
                bestDiff = diff;
            }
        }
        return best;
    }

    function applyBlur(x, y) {
        if (!blurLayersReady) return;
        const layer = getBlurLayerByStrength(state.blurStrength);
        if (!layer) return;

        const bCtx = baseCanvas.getContext('2d');
        const size = (state.blurSize / 100) * canvas.width;

        // 1. Create a temp canvas containing the pre-blurred layer
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.drawImage(layer.canvas, 0, 0);

        // 2. Create a Soft Mask (Vignette) based on Softness slider
        const maskCanvas2 = document.createElement('canvas');
        maskCanvas2.width = canvas.width;
        maskCanvas2.height = canvas.height;
        const mCtx2 = maskCanvas2.getContext('2d');

        if (state.blurSoftness > 0) {
            const r = size / 2;
            const hardness = 1.0 - state.blurSoftness;
            const r0 = r * hardness;
            const cx = x;
            const cy = y;

            mCtx2.beginPath();
            if (state.blurShape === 'circle') {
                mCtx2.arc(cx, cy, r, 0, Math.PI*2);
            } else {
                const rLarge = Math.max(size, size * 1.5);
                mCtx2.arc(cx, cy, rLarge, 0, Math.PI*2);
            }

            const grad = mCtx2.createRadialGradient(cx, cy, r0, cx, cy, r);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            mCtx2.fillStyle = grad;
            mCtx2.fill();
        } else {
            mCtx2.beginPath();
            if (state.blurShape === 'circle') {
                mCtx2.arc(x, y, size/2, 0, Math.PI*2);
            } else {
                mCtx2.rect(x - size/2, y - size/2, size, size);
            }
            mCtx2.fillStyle = '#FFFFFF';
            mCtx2.fill();
        }

        // 3. Apply Mask to the Pre-blurred Image
        tCtx.globalCompositeOperation = 'destination-in';
        tCtx.drawImage(maskCanvas2, 0, 0);

        // 4. Draw result onto Base Canvas
        bCtx.globalCompositeOperation = 'source-over';
        bCtx.drawImage(tempCanvas, 0, 0);

        render();
    }

    // 3. RETOUCH
    function setRetouchMode(mode) {
        state.retouchMode = mode;
        if (mode === 'pick') {
            document.getElementById('btnPickSource').classList.add('active');
            document.getElementById('btnPaintSource').classList.remove('active');
            document.getElementById('retouchStatus').textContent = "Tap image to pick source area";
        } else {
            document.getElementById('btnPaintSource').classList.add('active');
            document.getElementById('btnPickSource').classList.remove('active');
            document.getElementById('retouchStatus').textContent = "Painting mode active";
        }
    }

    function applyRetouch(currX, currY) {
        const bCtx = baseCanvas.getContext('2d');
        const size = (state.retouchSize / 100) * canvas.width;
        
        const offX = currX - retouchStartPos.x;
        const offY = currY - retouchStartPos.y;
        
        const srcX = state.cloneSource.x + offX;
        const srcY = state.cloneSource.y + offY;
        
        const temp = document.createElement('canvas');
        temp.width = size;
        temp.height = size;
        const tCtx = temp.getContext('2d');
        
        tCtx.drawImage(baseCanvas, srcX - size/2, srcY - size/2, size, size, 0, 0, size, size);
        
        const hardness = 1 - state.retouchSoftness;
        const r = size/2;
        const r0 = r * hardness;

        tCtx.globalCompositeOperation = 'destination-in';
        const grad = tCtx.createRadialGradient(size/2, size/2, r0, size/2, size/2, r);
        grad.addColorStop(0, 'rgba(0,0,0,1)'); 
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        tCtx.fillStyle = grad;
        tCtx.fillRect(0, 0, size, size);
        
        bCtx.globalCompositeOperation = 'source-over';
        bCtx.drawImage(temp, currX - size/2, currY - size/2);
        
        render();
    }

    // Utilities
    function invertMask() {
        if (!maskCanvas) return;
        pushHistory();
        const mCtx = maskCanvas.getContext('2d');
        const imgData = mCtx.getImageData(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < imgData.data.length; i += 4) {
            imgData.data[i+3] = 255 - imgData.data[i+3]; 
        }
        mCtx.putImageData(imgData, 0, 0);
        render();
        showToast('Inverted');
    }

    function clearMask() {
        if (!maskCanvas) return;
        pushHistory();
        const mCtx = maskCanvas.getContext('2d');
        mCtx.fillStyle = '#FFFFFF';
        mCtx.fillRect(0, 0, canvas.width, canvas.height);
        render();
        showToast('Cleared');
    }

    function resetProject() {
        if(confirm("Reset everything?")) {
            state.baseImg = null;
            state.overlayImg = null;
            baseCanvas = null; maskCanvas = null; overlayCanvas = null;
            maskHistory.length = 0; maskIndex = -1;
            baseHistory.length = 0; baseIndex = -1;
            blurLayers = [];
            blurLayersReady = false;
            ctx.clearRect(0,0, canvas.width, canvas.height);
            emptyState.style.display = 'block';
            document.getElementById('baseInput').value = '';
            document.getElementById('overlayInput').value = '';
        }
    }

    function saveImage() {
        if (!baseCanvas) {
            showToast('Nothing to save!');
            return;
        }
        showToast('Preparing image...');

        resetView(false);
        state.suppressOverlays = true;
        render({ showOverlays: false });

        canvas.toBlob((blob) => {
            state.suppressOverlays = false;
            render();

            if (!blob) return;
            const file = new File([blob], "blended-photo.png", { type: "image/png" });
            const isMobileShare = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobileShare && navigator.share && navigator.canShare({ files: [file] })) {
                navigator.share({ files: [file], title: 'Blended Photo', text: 'Created with LayerLab' })
                .then(() => showToast('Shared'))
                .catch((e) => { if(e.name !== 'AbortError') showToast('Share failed'); });
            } else {
                const link = document.createElement('a');
                link.download = 'blended-photo.png';
                link.href = URL.createObjectURL(blob);
                link.click();
                showToast('Saved');
            }
        }, 'image/png');
    }

    function showToast(msg) {
        toastEl.textContent = msg;
        toastEl.classList.add('show');
        setTimeout(() => toastEl.classList.remove('show'), 2000);
    }

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js').catch(() => {});
        });
    }

    init();
</script>
</body>
</html>